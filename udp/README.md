# Мини-отчет по выполнению задания

## 1. Общая реализация программы

Разработана клиент-серверная система передачи файлов на основе протокола UDP. Программа обеспечивает:
- **Подтверждение приема** каждой датаграммы через механизм ACK
- **Целостность передаваемой информации** с использованием CRC32
- **Многопользовательскую передачу** (одновременная работа с несколькими клиентами)
- **Симуляцию потери пакетов** через параметр командной строки
- **Визуализацию прогресса передачи** на клиенте и сервере

Программа реализована на языке C++ с использованием стандартной библиотеки и системных вызовов POSIX для работы с сокетами. Поддерживается стандарт C++20.

---

## 2. Архитектура и протокол передачи

### 2.1 Серверная часть
Сервер:
- Автоматически находит свободный порт через `bind` с нулевым номером порта
- Выводит назначенный порт через `getsockname`
- Обрабатывает входящие датаграммы, используя структуру `sockaddr_in` и функции `recvfrom`/`sendto`
- Для каждого клиента поддерживает состояние передачи в виде:
  ```cpp
  struct ClientState {
      std::vector<std::vector<char>> packets;
      uint32_t totalPackets;
      size_t totalDataSize;
      int droppedPackets;
      int crcErrors;
      std::chrono::steady_clock::time_point startTime;
  };
  ```

### 2.2 Клиентская часть
Клиент:
- Получает IP-адрес и порт сервера из аргументов командной строки
- Разбивает файл на части с учетом размера UDP-дейтаграмм
- Отправляет пакеты с заголовком, содержащим:
  ```cpp
  struct PacketHeader {
      uint32_t packetNumber;
      uint32_t totalPackets;
      uint32_t dataSize;
      uint32_t crc32;
  };
  ```
- Ожидает подтверждения получения (ACK) от сервера
- Повторяет отправку неподтвержденных пакетов

### 2.3 Протокол передачи
Протокол включает:
- **CRC32** для проверки целостности данных (IEEE 802.3)
- **Подтверждение приема** (ACK) через передачу номера принятого пакета
- **Повторную отправку** при отсутствии ACK
- **Механизм сегментации** файла на части по 1400 байт (с учетом размера заголовка)

---

## 3. Реализация ключевых функций

### 3.1 Обеспечение целостности данных
Для проверки целостности реализована функция вычисления CRC32 по IEEE 802.3:
```cpp
uint32_t calculateCRC32(const char* data, size_t length);
```
CRC вычисляется для полезной нагрузки и передается в заголовке пакета. Сервер проверяет CRC при приеме.

### 3.2 Обработка потерь пакетов
Сервер поддерживает симуляцию потерь через параметр `--loss`, принимающий список номеров пакетов для дропа:
```bash
./server --loss 10,100,1000
```
Реализован счетчик потерь для каждого номера пакета:
```cpp
std::vector<uint32_t> lossPackets;
std::vector<int> lossCounters;
```

### 3.3 Поддержка нескольких клиентов
Сервер использует ассоциативный контейнер для хранения состояния каждого клиента:
```cpp
std::unordered_map<ClientID, ClientState, ClientIDHash> clients;
```
Где `ClientID` содержит IP-адрес и порт клиента:
```cpp
struct ClientID {
    std::string ip;
    uint16_t port;
};
```

### 3.4 Многопоточность
- Клиент: 
  - Основной поток отправляет пакеты
  - Отдельный поток ожидает ACK
  - Прогресс-бар обновляется в отдельном потоке
- Сервер:
  - Основной поток обрабатывает входящие пакеты
  - Отдельный поток обновляет прогресс-бары для всех клиентов

---

## 4. Демонстрация возможностей

### 4.1 Запуск сервера
Сервер автоматически определяет свободный порт:
```cpp
sockaddr_in serverAddr{};
serverAddr.sin_family = AF_INET;
serverAddr.sin_addr.s_addr = INADDR_ANY;
serverAddr.sin_port = htons(0); // Автоматический выбор порта
bind(sockfd, reinterpret_cast<sockaddr*>(&serverAddr), sizeof(serverAddr));
getsockname(sockfd, reinterpret_cast<sockaddr*>(&serverAddr), &addrLen);
std::cout << "Server started on port: " << ntohs(serverAddr.sin_port) << std::endl;
```

### 4.2 Запуск клиента
Клиент получает параметры сервера из командной строки:
```bash
./client <server_ip> <server_port> <file_path> [delay_ms]
```
Реализованы:
- Парсинг IP-адреса через `inet_pton`
- Сохранение состояния передачи
- Настройка задержки между пакетами

### 4.3 Обнаружение ошибок
Сервер выводит информацию о:
- CRC-ошибках: `[ERROR] CRC mismatch in packet N | CRC errors: X`
- Потерянных пакетах: `[DROPPED] Packet N (as per loss rule) | Dropped total: X`

---

## 5. Демонстрация работы

### 5.1 Передача от нескольких клиентов
Сервер корректно обрабатывает одновременную передачу от нескольких клиентов:
1. Каждый клиент получает уникальное состояние в `clients`
2. Прогресс-бары обновляются независимо
3. Файлы сохраняются с уникальными именами: `received_file_from_<IP>`

### 5.2 Симуляция потерь пакетов
Сервер поддерживает параметр `--loss` для симуляции потери пакетов:
```cpp
for (size_t i = 0; i < lossPackets.size(); ++i) {
    if (lossPackets[i] == header->packetNumber && lossCounters[i] > 0) {
        lossCounters[i]--;
        dropPacket = true;
        break;
    }
}
```

### 5.3 Результаты приема
По завершении передачи сервер выводит статистику:
- Общий размер файла
- Время передачи
- Среднюю скорость
- Количество потерянных пакетов
- Количество CRC-ошибок

---

## 6. Заключение

Реализовано клиент-серверное приложение на основе UDP, удовлетворяющее требованиям:
- Обеспечена **надежная передача файлов** через UDP
- Реализованы **подтверждение приема** и **проверка целостности**
- Поддерживается **одновременная передача** от нескольких клиентов
- Добавлена **симуляция потерь пакетов**
- Визуализированы **прогресс-бары**